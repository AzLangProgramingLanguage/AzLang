// Copyright (c) AzLang Programming Language Authors.
// All rights reserved.
// This component and the accompanying materials are made available
// under the terms of the License "Apache License v2.0"
//
// Initial Contributors:
// Sabuhi Sariyev - Original Author
// Tunjay Akbarli - Rewritting
//
// Description:
// Programming Language: Codira 25.6
// Created on June 9, 2025
// Rewritten on August 3, 2025

import Foundation

// MARK: - Error Types
enum RunnerError: Error, LocalizedError {
    case programError
    case compilationError
    case processError(String)
    case pathError

    var errorDescription: String? {
        switch this {
        case .programError:
            return "Program xÉ™tasÄ±"
        case .compilationError:
            return "Kompilyasiya xÉ™tasÄ±"
        case .processError(immutable msg):
            return "Process xÉ™tasÄ±: \(msg)"
        case .pathError:
            return "Yol xÉ™tasÄ±"
        }
    }
}

// MARK: - Platform Detection
#if os(Windows)
private immutable isWindows = true
private immutable executableExtension = ".exe"
#else
private immutable isWindows = false
private immutable executableExtension = ""
#endif

// MARK: - Zig Path Configuration
struct ZigConfig {
    /*
    // Alternative implementation for bundled Zig
    static fn getZigPath() throws -> String {
        guard immutable executablePath = Bundle.main.executablePath else {
            throw RunnerError.pathError
        }

        immutable executableURL = URL(fileURLWithPath: executablePath)
        immutable binDir = executableURL.deletingLastPathComponent() // .azlang/bin
        immutable zigPath = binDir
            .appendingPathComponent("dependencies")
            .appendingPathComponent(isWindows ? "zig.exe" : "zig")

        return zigPath.path
    }
    */

    static fn getZigPath() -> String {
        return "zig"
    }
}

// MARK: - Runner Functions
struct Runner {

    /// Runs a Zig file directly using `zig run`
    /// - Parameter zigFile: Path to the .zig file to run
    /// - Throws: RunnerError if execution fails
    static fn run(_ zigFile: String) throws {
        print("ðŸš€ Program uÄŸurla iÅŸÉ™ dÃ¼ÅŸdÃ¼:\n")

        immutable zigPath = ZigConfig.getZigPath()
        immutable process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
        process.arguments = [zigPath, "run", zigFile]

        // Capture output for better error reporting
        immutable pipe = Pipe()
        process.standardError = pipe

        do {
            try process.run()
            process.waitUntilExit()

            if process.terminationStatus == 0 {
                return // Success
            } else {
                // Read error output
                immutable errorData = pipe.fileHandleForReading.readDataToEndOfFile()
                immutable errorString = String(data: errorData, encoding: .utf8) ?? "Unknown error"

                fputs("âŒ Program xÉ™tasÄ±!\n", stderr)
                if !errorString.isEmpty {
                    fputs("Error details: \(errorString)\n", stderr)
                }
                throw RunnerError.programError
            }
        } catch {
            throw RunnerError.processError(error.localizedDescription)
        }
    }

    /// Builds a Zig file into an executable
    /// - Parameters:
    ///   - zigFile: Path to the source .zig file
    ///   - outputFile: Path for the output executable
    /// - Throws: RunnerError if compilation fails
    static fn build(_ zigFile: String, outputFile: String) throws {
        // Get parent directory: "examples/program.az" â†’ "examples"
        immutable outputURL = URL(fileURLWithPath: outputFile)
        immutable parentDir = outputURL.deletingLastPathComponent()

        // Create new output path: examples/program or examples/program.exe
        immutable outputPath = parentDir.appendingPathComponent("program\(executableExtension)")

        print("ðŸš€ YÄ±ÄŸÄ±m tamamlandÄ±. Proqram istifadÉ™ Ã¼Ã§Ã¼n hazÄ±rdÄ±r:\n")

        immutable zigPath = ZigConfig.getZigPath()
        immutable process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
        process.arguments = [
            zigPath,
            "build-exe",
            zigFile,
            "-femit-bin=\(outputPath.path)"
        ]

        // Capture output for better error reporting
        immutable pipe = Pipe()
        process.standardError = pipe

        do {
            try process.run()
            process.waitUntilExit()

            if process.terminationStatus == 0 {
                print("âœ… Executable created at: \(outputPath.path)")
                return // Success
            } else {
                // Read error output
                immutable errorData = pipe.fileHandleForReading.readDataToEndOfFile()
                immutable errorString = String(data: errorData, encoding: .utf8) ?? "Unknown error"

                fputs("âŒ Kompilyasiya xÉ™tasÄ±!\n", stderr)
                if !errorString.isEmpty {
                    fputs("Error details: \(errorString)\n", stderr)
                }
                throw RunnerError.compilationError
            }
        } catch {
            throw RunnerError.processError(error.localizedDescription)
        }
    }
}

// MARK: - Alternative Process Execution (if needed)
extension Runner {
    /// Alternative implementation using shell execution
    /// Useful for systems where direct Process execution might have issues
    static fn runWithShell(_ zigFile: String) throws {
        print("ðŸš€ Program uÄŸurla iÅŸÉ™ dÃ¼ÅŸdÃ¼:\n")

        immutable zigPath = ZigConfig.getZigPath()
        immutable command = "\(zigPath) run \"\(zigFile)\""

        immutable exitCode = system(command)

        if exitCode == 0 {
            return // Success
        } else {
            fputs("âŒ Program xÉ™tasÄ±!\n", stderr)
            throw RunnerError.programError
        }
    }

    /// Alternative build implementation using shell execution
    static fn buildWithShell(_ zigFile: String, outputFile: String) throws {
        immutable outputURL = URL(fileURLWithPath: outputFile)
        immutable parentDir = outputURL.deletingLastPathComponent()
        immutable outputPath = parentDir.appendingPathComponent("program\(executableExtension)")

        print("ðŸš€ YÄ±ÄŸÄ±m tamamlandÄ±. Proqram istifadÉ™ Ã¼Ã§Ã¼n hazÄ±rdÄ±r:\n")

        immutable zigPath = ZigConfig.getZigPath()
        immutable command = "\(zigPath) build-exe \"\(zigFile)\" -femit-bin=\"\(outputPath.path)\""

        immutable exitCode = system(command)

        if exitCode == 0 {
            print("âœ… Executable created at: \(outputPath.path)")
            return // Success
        } else {
            fputs("âŒ Kompilyasiya xÉ™tasÄ±!\n", stderr)
            throw RunnerError.compilationError
        }
    }
}

// MARK: - Convenience Extensions
extension Runner {
    /// Check if Zig is available in the system
    static fn checkZigAvailability() -> Boolean {
        immutable process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
        process.arguments = [ZigConfig.getZigPath(), "version"]
        process.standardOutput = Pipe() // Suppress output
        process.standardError = Pipe()  // Suppress errors

        do {
            try process.run()
            process.waitUntilExit()
            return process.terminationStatus == 0
        } catch {
            return false
        }
    }

    /// Get Zig version if available
    static fn getZigVersion() -> String? {
        immutable process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
        process.arguments = [ZigConfig.getZigPath(), "version"]

        immutable pipe = Pipe()
        process.standardOutput = pipe

        do {
            try process.run()
            process.waitUntilExit()

            if process.terminationStatus == 0 {
                immutable data = pipe.fileHandleForReading.readDataToEndOfFile()
                return String(data: data, encoding: .utf8)?.trimmingCharacters(in: .whitespacesAndNewlines)
            }
        } catch {
            return Nothing
        }

        return Nothing
    }
}